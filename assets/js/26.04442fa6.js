(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{519:function(s,n,e){"use strict";e.r(n);var t=e(4),r=Object(t.a)({},(function(){var s=this,n=s.$createElement,e=s._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"关于路由守卫和拦截器配合使用做权限管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于路由守卫和拦截器配合使用做权限管理"}},[s._v("#")]),s._v(" 关于路由守卫和拦截器配合使用做权限管理")]),s._v(" "),e("h2",{attrs:{id:"关于权限管理思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于权限管理思路"}},[s._v("#")]),s._v(" 关于权限管理思路")]),s._v(" "),e("p",[e("strong",[s._v("当用户跳过登录之后的跳转页面，直接输入url直接进行跳转该怎么办？")])]),s._v(" "),e("p",[s._v("方法一：这是我目前掌握的唯一方法，需要后端配合着做\n1. 正常登录状态下（指从登录页登录到系统中），后端会返还给前端一个 token数据，一般是复杂的字符串形式\n2. 前端拿token之后存储到cookie中，在vue-router中进行全局的路由守卫（不管你从哪跳转，怎么跳转都会在跳转之前走这个方法），在这个守卫中，写入一个请求，向后端发送目前token内的值，此时若是登录过的账号会存储token，但是没登录过的或者是token不对的，在后台比较时会返回一个值，前台通过判断这个值，来选择下一步应当如何跳转：")]),s._v(" "),e("p",[e("strong",[s._v("这其中需要注意几个问题")])]),s._v(" "),e("ol",[e("li",[e("p",[s._v("首先就是数据的存储问题，尽量使用cookie来存储token")])]),s._v(" "),e("li",[e("p",[s._v("第二在写路由守卫的时候一定要注意逻辑关系，若是一个点击按钮有一个路由跳转事件的时候，要看看守卫中是否有符合他的跳转规则，若是有的话，要注意两者不能写重复也不能冲突")])])]),s._v(" "),e("h2",{attrs:{id:"路由守卫"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由守卫"}},[s._v("#")]),s._v(" 路由守卫")]),s._v(" "),e("p",[s._v("导航守卫的作用\n导航守卫是在vue-router中的提供的路由跳转的时候做一些事情，根据给定的条件来进行跳转\n全局守卫 router.beforeEach 主要是用来验证用户的登陆状态。\n局部导航守卫 router.beforeEnter 主要是用来守卫当前路由。")]),s._v(" "),e("p",[s._v("无论是全局守卫还是局部守卫，每个守卫的方法都有三个参数， to, from, next")]),s._v(" "),e("ul",[e("li",[s._v("to: 即将要进入的路由对象")]),s._v(" "),e("li",[s._v("from: 当前导航要离开的路由")]),s._v(" "),e("li",[s._v("next: 一个回调函数， 一定要调用这个方法，不然路由不会继续往下")]),s._v(" "),e("li",[s._v("resolve 类似 node 中的中间件。")])]),s._v(" "),e("h2",{attrs:{id:"axios拦截"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#axios拦截"}},[s._v("#")]),s._v(" axios拦截")]),s._v(" "),e("h3",{attrs:{id:"axios拦截器的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#axios拦截器的作用"}},[s._v("#")]),s._v(" axios拦截器的作用")]),s._v(" "),e("p",[s._v("在请求发送或响应被.then 或者 .catch 之前先拦截下来 分为请求拦截器和响应拦截器， 在发送请求和接收响应的时候触发 拦截器中的回调函数一定要有返回值")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("\n// 设置请求拦截\naxios.interceptors.request.use(function (config) {\n    // 在请求头中加入 token\n    config.headers.Authorization = window.sessionStorage.getItem(\"token\");\n    // Do something before request is sent\n    return config;\n}, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n});\n\n// 设置响应拦截\naxios.interceptors.response.use(function (response) {\n    // 在响应回来的数据中先判断 token 是否有效， 如果无效则让用户重新登陆\n    if (response.data.meta.status == 400 && response.data.meta.msg == \"无效token\") {\n        Vue.prototype.$message.warning('请先登录')\n        router.push('/login')\n    }\n    // Do something with response data\n    return response;\n}, function (error) {\n    // Do something with response error\n    return Promise.reject(error);\n});\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br")])]),e("h2",{attrs:{id:"二者分工"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二者分工"}},[s._v("#")]),s._v(" 二者分工")]),s._v(" "),e("p",[s._v("导航守卫和axios拦截器的区别\n导航守卫只是前端这边做判断，检查请求头中是否带有token， 并不能判断 token 是否失效。\n而 axios拦截器是发送请求到后端那边，后端来判断token的有效性，再决定用户的登陆状态。\n两者可以一起配合使用 来保证登陆状态")])])}),[],!1,null,null,null);n.default=r.exports}}]);