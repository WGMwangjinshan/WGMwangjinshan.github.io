(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{517:function(s,e,n){"use strict";n.r(e);var a=n(4),t=Object(a.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"认为对promise的理解太泛泛了，只知怎么用，不知为何，今天特做详细解析。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#认为对promise的理解太泛泛了，只知怎么用，不知为何，今天特做详细解析。"}},[s._v("#")]),s._v(" 认为对promise的理解太泛泛了，只知怎么用，不知为何，今天特做详细解析。")]),s._v(" "),n("h2",{attrs:{id:"什么是promise？他干什么了？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是promise？他干什么了？"}},[s._v("#")]),s._v(" 什么是Promise？他干什么了？")]),s._v(" "),n("p",[s._v("ES6提供了Promise对象，他是异步的一种实现方法，听名字嘛，Promise（承诺）就是答应了一件事，但是我做不做不一定，通过这种方式来实现了异步。Promise本身是一个构造函数，用于生成Promise实例，用new来生成。")]),s._v(" "),n("h2",{attrs:{id:"为什么要出promise？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要出promise？"}},[s._v("#")]),s._v(" 为什么要出Promise？")]),s._v(" "),n("p",[s._v("按我理解就是为了偷懒，穿透的异步回调可能会因为业务逻辑的复杂，代码要写的很嵌套，就是“回调地狱”。")]),s._v(" "),n("p",[s._v("所以出现了Promise的链式编程来解决这个问题。给我的感觉就是一切皆可点")]),s._v(" "),n("p",[s._v("看看他是怎么用的哈：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("        Promise.resolve().then(() => {\n        \x3c!--注意这步是同步的哈，点then之后才是异步操作--\x3e\n            console.log(6)\n        }).then(() => {\n            console.log(7)\n        });\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("h2",{attrs:{id:"promise是怎么个原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise是怎么个原理"}},[s._v("#")]),s._v(" Promise是怎么个原理")]),s._v(" "),n("p",[n("strong",[s._v("promise对象的状态有三种：pending(等待态),resolved(成功态),rejected(失败态)，只能从等待态转化成成功态或失败态；")])]),s._v(" "),n("p",[s._v("那针对这几种状态我举个例子：")]),s._v(" "),n("blockquote",[n("p",[s._v("假设有一天小美和小明在大海里游泳，小美突然被海草缠住了脚（注意这个时候小美被缠住脚的事件已经发生了），这个时候小明说“你在这不要动，我去找人来救你”。这个时候小明给小美了一个承诺（Promise），这个时候的状态就是等待态（pending），这个时候就有两种可能了，小明带人来了（成功态resolved），小明跑了没管小美（失败态rejected）。我们可以看到在这个事中，只能事从pending到resolved或者到rejected的过程，他是不可逆的。")])]),s._v(" "),n("p",[s._v("上面举了这个例子来说Promise的原理是啥，那我们现在想个场景，这个场景体现出了Promise的优势。")]),s._v(" "),n("blockquote",[n("p",[s._v("假设我们接着上面的故事讲，小美说：“我的明~~，你要是带人来救我，我就嫁给你！！”（那这个时候又产生了一个Promise），那小明听到了就很激动啊，回复到：“我的美~~~，你要是嫁给我，你肯定会是天下最幸福的女人”（又产生了一个Promise）。。。。。。。")])]),s._v(" "),n("p",[s._v("上面这个故事就说到这，要是一直说我能写到地球毁灭了，反正意思就是可能会出现回调“套娃”的情况，所以这个时候肯定.then的写法比嵌套的写法要好太多太多了。")]),s._v(" "),n("p",[n("strong",[s._v("同时这个东西的实现也就是这么个思路。")])]),s._v(" "),n("h2",{attrs:{id:"手撕一个promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#手撕一个promise"}},[s._v("#")]),s._v(" 手撕一个Promise")]),s._v(" "),n("p",[s._v("废话不多说，不懂就给我实现它！！！！")]),s._v(" "),n("p",[s._v("这个思路也是在网上找的，通过这个思路我也找到了编写的灵感。")]),s._v(" "),n("ol",[n("li",[s._v("最开始肯定是写个函数（就好比这俩人游泳去了），传入一个同步执行的方法家叫execuotor（就好比小美被海草缠住脚）")]),s._v(" "),n("li",[s._v("用一个字段（status）来记录Promise的状态，默认是“pending”，成功是“resolved”，失败是“rejected”，重写resolved和rejected方法，执行这两个方法时把status改变，以便以后then方法调用。")]),s._v(" "),n("li",[s._v("执行then方法时，依据status字段来执行成功方法或者失败方法。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function Promise(executor) {\n    let self = this;\n    self.status = 'pending'\n    self.value = undefined\n    self.reason = undefined\n\n    function resolve(value) {\n        if (self.status == 'pending') {\n            self.value = value;\n            self.status = 'resolved'\n        }\n    }\n    function reject(reason) {\n        if (self.status == 'pending') {\n            self.reason = reason\n            self.status = 'rejected'\n        }\n    }\n\n    try {\n        executor(resolve, reject)\n    }\n    catch{\n        reject(e);\n    }\n}\nPromise.prototype.then = function (onFulfilled, onRejected) {\n    let self = this\n    if(self.status == 'resolved')\n    {\n        onFulfilled(self.value)\n    }\n    if(self.status == 'rejected'){\n        onRejected(self.reason)\n    }\n}\n\nmodule.exports = Promise\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br")])]),n("p",[s._v("我感觉现在的功能不是很完善，能支持的程度也比较低，若是感觉代码哪不完善的话，麻烦您再评论区给我讲讲！！")])])}),[],!1,null,null,null);e.default=t.exports}}]);